<div class="wrapper">
  <nav style='float:left;margin-top:40px;'>
    <h1 style='font-weight: bold;color:#2786c2;'>
      <a href='http://bigbinary.github.com/letsarel/'> Let's arel </a>
    </h1>
    <br />
  <ul>
  </ul>

  <br />
  <a href='http://bigbinary.com'>
    <img src='http://blog.bigbinary.com/images/bigbinary_logo.jpg' width='162' height='42'>
  </a>

  </nav>

  <section style='float:right;'>
    <h1>Introduction</h1>

    <p>
      <a href='https://github.com/rails/arel'>Arel</a> is awesome. Here we are going to discuss some of the neat fetures we came across.
    </p>

    <p>
      Here is the <a href='http://github.com/bigbinary/letsarel'>git repo</a> for lets arel.
      To follow along execute following commands
    </p>
    <ul>
      <li>
        <code>git clone git://github.com/bigbinary/letsarel.git</code>
      </li>
      <li>
        <code>cd letsarel</code>
      </li>
      <li>
        <code>rake db:setup</code>
      </li>
    </ul>

    <h1>Case study</h1>

    <p>
      To discuss various queries we are going to use bunch of models like
      <code>Movie</code>, <code>Person</code>, <code>Production house</code>
      etc.  If you want to look at <a href='https://github.com/bigbinary/letsarel/blob/master/db/schema.rb'>schema</a> then go ahead but the
      model will get clearer as we study various cases.
    </p>


    <h2>Using merge</h2>

    <p>
    Here is how I would write the query at first attempt
    </p>

<pre>
<code>
# query
Person.joins(collaborations: { :movie {productions: ).where(collaborations: { role: 'actor' }, movies: {genre: 'superhero' }, production_houses: {name: 'DC Comics'})

# generated sql
SELECT "people".* FROM "people"
INNER JOIN "collaborations" ON "collaborations"."person_id" = "people"."id"
INNER JOIN "movies" ON "movies"."id" = "collaborations"."movie_id"
WHERE "collaborations"."role" = 'actor' AND "movies"."genre" = 'superhero'

# result
Person id: 233763071, first_name: "Christian", last_name: "Bale",
created_at: "2012-07-24 15:31:52", updated_at: "2012-07-24 15:31:52"
</code>
</pre>

    <p>
      Production house <code>DC Comics</code> has produced a number of movies. I want to
      know all the names of all actors for <code>superhero</code> genre movies belonging to production
      house <code>DC Comics</code>.
    </p>

    <p>
      So the requirement is:
    </p>
    <ul>
      <li>
        Get names of people
      </li>
      <li>
        production house == 'DC Comics'
      </li>
      <li>
        movie genre == 'superhero'
      </li>
    </ul>

    <h3>Query</h3>

<pre>
<code>
# query
Person.
joins(collaborations: { movie: { productions: :production_house } }).
merge(Movie.superhero).
merge(ProductionHouse.dccomics).
merge(Collaboration.as_actor)

#generated sql
SELECT "people".* FROM "people"
INNER JOIN "collaborations" ON "collaborations"."person_id" = "people"."id"
INNER JOIN "movies" ON "movies"."id" = "collaborations"."movie_id"
INNER JOIN "productions" ON "productions"."movie_id" = "movies"."id"
INNER JOIN "production_houses" ON "production_houses"."id" = "productions"."production_house_id"
WHERE "movies"."genre" = 'superhero'
AND "production_houses"."name" = 'DC Comics'
AND "collaborations"."role" = 'actor'

</code>
</pre>


    <h3>Query using include</h3>

<pre>
<code>
Person.
includes(collaborations: { movie: { productions: :production_house } }).
merge(Movie.superhero).
merge(ProductionHouse.dccomics).
merge(Collaboration.as_actor)
</code>
</pre>

    <h3>Generated sql</h3>

<pre>
<code>
SELECT "people"."id" AS t0_r0, "people"."first_name" AS t0_r1, "people"."last_name" AS t0_r2,
"people"."created_at" AS t0_r3, "people"."updated_at" AS t0_r4, "collaborations"."id" AS t1_r0,
"collaborations"."movie_id" AS t1_r1, "collaborations"."person_id" AS t1_r2,
"collaborations"."role" AS t1_r3, "collaborations"."paid" AS t1_r4,
"collaborations"."created_at" AS t1_r5, "collaborations"."updated_at" AS t1_r6,
"movies"."id" AS t2_r0, "movies"."title" AS t2_r1, "movies"."budget" AS t2_r2,
"movies"."revenue" AS t2_r3, "movies"."released_on" AS t2_r4, "movies"."genre" AS t2_r5,
"movies"."distributor_id" AS t2_r6, "movies"."created_at" AS t2_r7,
"movies"."updated_at" AS t2_r8, "productions"."id" AS t3_r0, "productions"."movie_id" AS t3_r1,
"productions"."production_house_id" AS t3_r2, "productions"."created_at" AS t3_r3,
"productions"."updated_at" AS t3_r4, "production_houses"."id" AS t4_r0,
"production_houses"."name" AS t4_r1, "production_houses"."created_at" AS t4_r2,
"production_houses"."updated_at" AS t4_r3 FROM "people"
LEFT OUTER JOIN "collaborations" ON "collaborations"."person_id" = "people"."id"
LEFT OUTER JOIN "movies" ON "movies"."id" = "collaborations"."movie_id"
LEFT OUTER JOIN "productions" ON "productions"."movie_id" = "movies"."id"
LEFT OUTER JOIN "production_houses" ON "production_houses"."id" = "productions"."production_house_id"
WHERE "movies"."genre" = 'superhero' AND
"production_houses"."name" = 'DC Comics' AND
"collaborations"."role" = 'actor'
</code>
</pre>

    <h2>Using except</h2>

    <p>
      In the previous section we saw that <code>merge</code> is
      great.  However it would fail in a few cases. Here is an
      example where <code>merge</code> fails.
    </p>

    <p>
      Imagine a case where the the scope that is being merged itself
      has a join. Here is an example.
    </p>

<pre>
<code>
class Movie < ActiveRecord::Base
.......
scope :dccomics, lambda { joins(:production_houses).merge(ProductionHouse.dccomics) }
.......
end
</code>
</pre>

    <h3>Query that fails</h3>

<pre>
<code>
Person.
joins(movies: :production_houses).
merge(Movie.dccomics)
</code>
</pre>

      <h3>Query fails with following error</h3>
<pre>
<code>
Person.joins(movies: :production_houses).merge(Movie.dccomics).to_a
ActiveRecord::ConfigurationError: Association named 'production_houses' was not found; perhaps you misspelled it?
from /Users/subbarao/.rbenv/versions/1.9.3-p0/lib/ruby/gems/1.9.1/gems/activerecord-3.2.6/lib/active_record/associations/join_dependency.rb:112:in `build'
</code>
</pre>

<h3>Why did the query fail</h3>

<p>The query failed because merge method combines the joins of the merge
and assigns it to the current scope. Check this out.</p>

<pre>
<code>
Person.joins(movies: :production_houses).merge(Movie.dccomics).joins_values
=> [{:movies=>:production_houses}, :production_houses]
</code>
</pre>

<p>
But you can not directly join from person to production_houses, you can only do it through movies which the
join is doing. so production_houses join in the merged scope is wrong. we need to merge scope without join.
</p>


<p>
This is where <code>except</code> comes in picture. Using
<code>except</code>  the extra <code>:production_houses</code> can be
removed.
</p>

<pre>
<code>
Person.joins(movies: :production_houses).merge(Movie.dccomics.except(:joins)).joins_values
=> [{:movies=>:production_houses}]
</code>
</pre>

<p>
Now the combined join looks good for the scope.
</p>

<pre>
<code>
Person.joins(movies: :production_houses).merge(Movie.dccomics.except(:joins))
</code>
</pre>

<h3>The final working sql with except</h3>

<pre>
<code>
SELECT "people".* FROM "people"
INNER JOIN "collaborations" ON "collaborations"."person_id" = "people"."id"
INNER JOIN "movies" ON "movies"."id" = "collaborations"."movie_id"
INNER JOIN "productions" ON "productions"."movie_id" = "movies"."id"
INNER JOIN "production_houses" ON "production_houses"."id" = "productions"."production_house_id"
WHERE "production_houses"."name" = 'DC Comics'
</code>
</pre>

  </section>
</div>

