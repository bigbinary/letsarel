<div class="wrapper">
  <nav style='float:left;margin-top:40px;'>
    <h1 style='font-weight: bold;color:#2786c2;'>
      <a href='http://bigbinary.github.com/letsarel/'> Let's arel </a>
    </h1>
    <br />
  <ul>
  </ul>

  <br />
  <a href='http://bigbinary.com'>
    <img src='http://blog.bigbinary.com/images/bigbinary_logo.jpg' width='162' height='42'>
  </a>

  </nav>

  <section style='float:right;'>
    <h1>Introduction</h1>

    <p>
      <a href='https://github.com/rails/arel'>Arel</a> is awesome. Here we are going to discuss some of the neat fetures we came across.
    </p>

    <p>
      Here is the <a href='http://github.com/bigbinary/letsarel'>git repo</a> for lets arel.
      To follow along execute following commands
    </p>
    <ul>
      <li>
        <code>git clone git://github.com/bigbinary/letsarel.git</code>
      </li>
      <li>
        <code>cd letsarel</code>
      </li>
      <li>
        <code>rake db:setup</code>
      </li>
    </ul>

    <h1>Case study</h1>

    <p>
      To discuss various queries we are going to use bunch of models like
      <code>Movie</code>, <code>Person</code>, <code>Production house</code>
      etc.  If you want to look at <a href='https://github.com/bigbinary/letsarel/blob/master/db/schema.rb'>schema</a> then go ahead but the
      model will get clearer as we study various cases.
    </p>


    <h2>Using merge</h2>

    <p>
      Production house <code>DC Comics</code> has produced a number of movies. I want to
      know all the names of all actors for <code>superhero</code> genre movies belonging to production
      house <code>DC Comics</code>.
    </p>

    <p>
      So the requirement is:
    </p>
    <ul>
      <li> Get names of people </li>
      <li> production house == 'DC Comics' </li>
      <li> movie genre == 'superhero' </li>
      <li> collaborators role == 'superhero' </li>
    </ul>

    <p>
    Here is how I would write the query at first attempt
    </p>

<pre>
<code>
Person.joins(collaborations: { movie: {productions: :production_house }} ).
  where(collaborations: { role: 'actor' }).
  where(movies: {genre: 'superhero' }).
  where(production_houses: {name: 'DC Comics'})

# generated sql
SELECT "people".* FROM "people"
INNER JOIN "collaborations" ON "collaborations"."person_id" = "people"."id"
INNER JOIN "movies" ON "movies"."id" = "collaborations"."movie_id"
INNER JOIN "productions" ON "productions"."movie_id" = "movies"."id"
INNER JOIN "production_houses" ON "production_houses"."id" = "productions"."production_house_id"
WHERE "collaborations"."role" = 'actor'
AND "movies"."genre" = 'superhero'
AND "production_houses"."name" = 'DC Comics'

# result
[Person id: 57213424, first_name: "Christopher", last_name: "Reeve"]
</code>
</pre>

    <p>
      In the above case we did not use the named scope that we already had created.
    </p>

    <h3>Query</h3>

<pre>
<code>
# query using merge
Person.joins(collaborations: { movie: { productions: :production_house } }).
  merge(Movie.superhero).
  merge(ProductionHouse.dccomics).
  merge(Collaboration.as_actor)

#generated sql
SELECT "people".* FROM "people"
INNER JOIN "collaborations" ON "collaborations"."person_id" = "people"."id"
INNER JOIN "movies" ON "movies"."id" = "collaborations"."movie_id"
INNER JOIN "productions" ON "productions"."movie_id" = "movies"."id"
INNER JOIN "production_houses" ON "production_houses"."id" = "productions"."production_house_id"
WHERE "movies"."genre" = 'superhero'
AND "production_houses"."name" = 'DC Comics'
AND "collaborations"."role" = 'actor'

# result
[Person id: 57213424, first_name: "Christopher", last_name: "Reeve"]
</code>
</pre>


    <h3>Query using include</h3>

<pre>
<code>
# query using merge and using include instead of join
Person.includes(collaborations: { movie: { productions: :production_house } }).
  merge(Movie.superhero).
  merge(ProductionHouse.dccomics).
  merge(Collaboration.as_actor)

# generated sql
SELECT "people"."id" AS t0_r0, "people"."first_name" AS t0_r1, "people"."last_name" AS t0_r2,
"people"."created_at" AS t0_r3, "people"."updated_at" AS t0_r4, "collaborations"."id" AS t1_r0,
"collaborations"."movie_id" AS t1_r1, "collaborations"."person_id" AS t1_r2,
"collaborations"."role" AS t1_r3, "collaborations"."paid" AS t1_r4,
"collaborations"."created_at" AS t1_r5, "collaborations"."updated_at" AS t1_r6,
"movies"."id" AS t2_r0, "movies"."title" AS t2_r1, "movies"."budget" AS t2_r2,
"movies"."revenue" AS t2_r3, "movies"."released_on" AS t2_r4, "movies"."genre" AS t2_r5,
"movies"."distributor_id" AS t2_r6, "movies"."created_at" AS t2_r7,
"movies"."updated_at" AS t2_r8, "productions"."id" AS t3_r0, "productions"."movie_id" AS t3_r1,
"productions"."production_house_id" AS t3_r2, "productions"."created_at" AS t3_r3,
"productions"."updated_at" AS t3_r4, "production_houses"."id" AS t4_r0,
"production_houses"."name" AS t4_r1, "production_houses"."created_at" AS t4_r2,
"production_houses"."updated_at" AS t4_r3 FROM "people"
LEFT OUTER JOIN "collaborations" ON "collaborations"."person_id" = "people"."id"
LEFT OUTER JOIN "movies" ON "movies"."id" = "collaborations"."movie_id"
LEFT OUTER JOIN "productions" ON "productions"."movie_id" = "movies"."id"
LEFT OUTER JOIN "production_houses" ON "production_houses"."id" = "productions"."production_house_id"
WHERE "movies"."genre" = 'superhero' AND
"production_houses"."name" = 'DC Comics' AND
"collaborations"."role" = 'actor'

# result
[Person id: 57213424, first_name: "Christopher", last_name: "Reeve"]
</code>
</pre>

    <h2>Using except</h2>

    <p>
      In the previous section we saw that <code>merge</code> is
      great.  However it would fail in a few cases. Here is an
      example where <code>merge</code> fails.
    </p>

    <p>
      Imagine a case where the the scope that is being merged itself
      has a join. Here is an example.
    </p>

<pre>
<code>
class Movie < ActiveRecord::Base
  scope :dccomics, lambda { joins(:production_houses).merge(ProductionHouse.dccomics) }
end
</code>
</pre>

    <h3>Query fails</h3>

<pre>
<code>
Person.joins(movies: :production_houses).merge(Movie.dccomics)

# fails with following error
ActiveRecord::ConfigurationError: Association named 'production_houses' was not found;
perhaps you misspelled it?
</code>
</pre>

<h3>Why did the query fail</h3>

<p>The query failed because merge method combines the joins of the merge
and assigns it to the current scope. Check this out.</p>

<pre>
<code>
Person.joins(movies: :production_houses).merge(Movie.dccomics).joins_values
=> [{:movies=>:production_houses}, :production_houses]
</code>
</pre>

<p>
But you can not directly join from person to production_houses, you can only do it through movies which the
join is doing. so production_houses join in the merged scope is wrong. we need to merge scope without join.
</p>


<p>
This is where <code>except</code> comes in picture. Using
<code>except</code>  the extra <code>:production_houses</code> can be
removed.
</p>

<pre>
<code>
Person.joins(movies: :production_houses).merge(Movie.dccomics.except(:joins)).joins_values
=> [{:movies=>:production_houses}]
</code>
</pre>

<p>
Now the combined join looks good for the scope.
</p>

<pre>
<code>
Person.joins(movies: :production_houses).merge(Movie.dccomics.except(:joins))
</code>
</pre>

<h3>The final working sql with except</h3>

<pre>
<code>
SELECT "people".* FROM "people"
INNER JOIN "collaborations" ON "collaborations"."person_id" = "people"."id"
INNER JOIN "movies" ON "movies"."id" = "collaborations"."movie_id"
INNER JOIN "productions" ON "productions"."movie_id" = "movies"."id"
INNER JOIN "production_houses" ON "production_houses"."id" = "productions"."production_house_id"
WHERE "production_houses"."name" = 'DC Comics'
</code>
</pre>

  </section>
</div>

